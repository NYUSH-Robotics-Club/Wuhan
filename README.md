# VEXCODE-2024-2025
CPSLO VexCode 2024-2025

## 机器人配置

此项目支持两种不同的机器人配置：

### GREEN配置（主配置）
- **驱动电机**: 
  - 左侧: PORT1-PORT4 (比例 6:1)
  - 右侧: PORT5-PORT8 (比例 6:1)
- **进料系统**: 
  - 滚轮: PORT11 (比例 18:1)
  - 传送带: PORT12 (比例 18:1)
- **壁桩系统**: 
  - 左电机: PORT13 (比例 36:1)
  - 右电机: PORT14 (比例 36:1)
  - 旋转传感器: PORT15
- **气动系统**:
  - 移动目标机构: Brain.ThreeWirePort.H
  - 推杆右: Brain.ThreeWirePort.G
  - 推杆左: Brain.ThreeWirePort.F
- **传感器**:
  - 颜色检测: PORT19 (光学传感器)
  - 距离传感器: PORT20
  - IMU陀螺仪: PORT21

### GOLD配置（备用配置）
- 金色机器人的备用端口配置

## 编译配置

在 `makefile` 中默认使用GREEN配置：
```makefile
CPPFLAGS += -DGREEN
# CPPFLAGS += -DGOLD
```

## 🎮 遥控器操作键位

### **肩部按键**
| 按键 | 功能 | 详细说明 |
|------|------|----------|
| **L1** | 进料系统正转 | 启动滚轮和传送带正转，同时启用环检测覆盖 |
| **L2** | 进料系统反转 | 按下时反转，释放时停止 |
| **R1** | 壁桩状态切换 | 循环切换：归零(0°) → 装载(16°) → 预得分(75°) → 得分(60°) → 自动归零 |
| **R2** | 移动目标机构 | 开关移动目标抓取机构，带震动反馈 |

### **方向键**
| 按键 | 功能 | 详细说明 |
|------|------|----------|
| **⬆️ Up** | 蓝方模式 | 设置为蓝方机器人，丢弃红色环 |
| **⬇️ Down** | 右侧推杆 | 切换右侧推杆气动装置 |
| **⬅️ Left** | 红方模式 | 设置为红方机器人，丢弃蓝色环 |
| **➡️ Right** | 翻转器 | 切换翻转器气动装置 |

### **面部按键**
| 按键 | 功能 | 详细说明 |
|------|------|----------|
| **A** | 自动进料 | 持续进料直到检测到环，带震动提示 |
| **B** | 左侧推杆 | 切换左侧推杆气动装置 |
| **X** | 锁定自动程序 | 锁定选择的自动程序并校准陀螺仪 |
| **Y** | 解锁自动程序 | 解锁自动程序选择，允许重新选择 |

#### **特殊功能说明**
- **X键**: 在自动程序选择界面使用，锁定当前选择的程序并开始陀螺仪校准，防止误操作
- **Y键**: 有两个功能：
  1. 在自动程序锁定后，可以解锁重新选择程序
  2. 在壁桩预得分状态(68°)时，按Y键可微调到59度并自动回收到装载位置

### **摇杆控制**
| 摇杆 | 功能 | 详细说明 |
|------|------|----------|
| **左摇杆** | 底盘驱动 | 街机式控制（前进后退+转向） |
| **右摇杆Y轴** | 手动壁桩 | 直接控制壁桩电机，覆盖自动控制 |

### **壁桩系统角度设置**
| 状态 | GREEN角度 | GOLD角度 | 功能 |
|------|-----------|----------|------|
| **归零** | 0° | 0° | 基准位置，系统初始化 |
| **装载** | 16° | 16° | 装载环的位置 |
| **预得分** | 75° | 75° | 准备得分位置 |
| **得分** | 60° | 60° | 最终得分位置 |

### **颜色检测系统**
- **LED亮度**: 25%（节能优化）
- **红色检测**: 350-10度色调范围
- **蓝色检测**: 205-225度色调范围
- **自动分拣**: 根据阵营设置自动丢弃错误颜色的环

### **自动程序选择**
- **Brain屏幕点击**: 循环切换自动程序
- **X键**: 锁定选择的自动程序并校准陀螺仪
- **Y键**: 解锁自动程序选择，允许重新选择

## 🤖 自动程序极详细解析

### **GREEN机器人 - 红方中央冲刺程序**

**起始位置**: 机器人面向前方，位于红方起始线上，距离中央移动目标约34英寸
**总用时**: 约15秒
**策略**: 抓取中央移动目标，收集环，在联盟壁桩得分，最后触碰梯子

#### **第一阶段：抓取中央移动目标 (0-3秒)**

1. **启动进料系统**
   - 滚轮电机以12V正转启动
   - 目的：为后续收集环做准备

2. **伸出左推杆**
   - 左推杆气动装置激活伸出
   - 目的：准备抓取中央移动目标

3. **直线冲刺**
   - 机器人以最大电压12V直线前进34英寸
   - 速度：约每秒24英寸
   - 目的：快速到达中央移动目标位置

4. **抓取移动目标**
   - 左推杆气动装置收缩夹紧
   - 滚轮电机切换为12V反转
   - 目的：牢固抓取中央移动目标并开始将其拖拽

#### **第二阶段：移动目标定位 (3-6秒)**

5. **导航到预定位置**
   - 机器人拖拽移动目标到坐标(30.1, -42.3)
   - 使用底盘PID控制确保精确定位
   - 目的：将移动目标移动到战略位置

6. **调整朝向**
   - 机器人转向面对坐标(24, 0)
   - 目的：为下一步动作做准备

7. **精确微调**
   - 底盘电压降低到8V进行精确控制
   - 向前移动2英寸进行最终定位
   - 目的：确保移动目标在最佳位置

#### **第三阶段：释放并抓取移动目标 (6-9秒)**

8. **释放移动目标**
   - 左推杆伸出释放移动目标
   - 等待0.3秒确保完全释放
   - 目的：准备用移动目标机构重新抓取

9. **后退并收起推杆**
   - 机器人后退8英寸
   - 左推杆收缩到原位
   - 目的：为移动目标机构抓取腾出空间

10. **转向移动目标**
    - 机器人转向160度（几乎180度转身）
    - 目的：用机器人后部的移动目标机构面对移动目标

#### **第四阶段：移动目标机构抓取 (9-11秒)**

11. **缓慢接近**
    - 以低电压3-3.5V缓慢后退24英寸
    - 目的：精确控制，避免撞击移动目标

12. **抓取序列**
    - 移动目标机构气动装置激活抓取
    - 等待0.1秒确保抓牢
    - 向前移动5英寸测试抓取
    - 释放并重新抓取确保牢固
    - 再次后退5英寸到最终位置
    - 目的：确保移动目标被牢固抓取

#### **第五阶段：收集环 (11-13秒)**

13. **转向收集区域**
    - 机器人转向90度面向场地中央
    - 目的：朝向环密集区域

14. **启动收集系统**
    - 滚轮以12V正转
    - 传送带以9V正转
    - 目的：开始自动收集和分拣环

15. **移动到环区域**
    - 以低速3.5V移动到坐标(57, -24)
    - 目的：收集途中的环

16. **转向得分区域**
    - 转向坐标(48, -47)
    - 移动到该位置
    - 目的：将收集的环装载到移动目标上

#### **第六阶段：移动目标得分 (13-14秒)**

17. **定位移动目标**
    - 转向坐标(55, -40)，背对该点
    - 移动到该位置
    - 目的：将移动目标放置在得分区域

18. **释放移动目标**
    - 等待0.3秒确保稳定
    - 移动目标机构释放
    - 等待0.1秒确保完全释放
    - 目的：完成移动目标得分

#### **第七阶段：联盟壁桩得分 (14-15秒)**

19. **前往联盟壁桩**
    - 转向坐标(24, -24)进行中转
    - 然后转向联盟壁桩位置(-2, -60)
    - 等待3秒让队友完成动作
    - 目的：避免与队友冲突

20. **壁桩得分准备**
    - 激活壁桩状态切换（装载→预得分→得分）
    - 等待0.4秒壁桩系统响应
    - 目的：准备在联盟壁桩得分

21. **精确对准**
    - 转向坐标(0, -72)
    - 以6V电压前进650毫秒对准壁桩
    - 目的：确保壁桩得分位置准确

22. **壁桩得分**
    - 后退9英寸
    - 传送带反转2.5V将环送入壁桩
    - 壁桩电机4.5V正转1.6秒完成得分
    - 目的：将环得分到联盟壁桩

#### **第八阶段：触碰梯子 (15秒)**

23. **微调对准**
    - 左右微调确保完美对准
    - 转向坐标(-6, -72)、(6, -72)、(0, -72)
    - 目的：确保后续动作精确

24. **前往梯子**
    - 后退离开壁桩
    - 转向坐标(0, -24)
    - 全速前进1.2秒到达梯子
    - 目的：触碰梯子获得额外分数

25. **触碰梯子**
    - 翻转器气动装置激活
    - 壁桩系统反转回收
    - 目的：完成梯子触碰得分

### **GREEN机器人 - 蓝方中央冲刺程序**

**起始位置**: 机器人面向前方，位于蓝方起始线上
**总用时**: 约15秒
**策略**: 与红方程序镜像，使用右推杆抓取中央移动目标

#### **程序流程**（与红方镜像）

1. **启动与冲刺**
   - 滚轮12V正转启动
   - 右推杆伸出（而非左推杆）
   - 直线前进34英寸到中央移动目标

2. **抓取与定位**
   - 右推杆收缩抓取移动目标
   - 滚轮反转拖拽
   - 导航到坐标(-30.1, -42.3)（镜像坐标）

3. **重新抓取**
   - 转向(-24, 0)
   - 释放推杆，后退，收缩推杆
   - 转向-160度（镜像角度）

4. **移动目标机构抓取**
   - 缓慢后退23英寸
   - 移动目标机构抓取序列
   - 确保牢固抓取

5. **收集与得分**
   - 转向-90度（镜像方向）
   - 启动收集系统
   - 移动到(-57, -24)收集环
   - 移动目标得分

6. **联盟壁桩得分**
   - 前往蓝方联盟壁桩
   - 精确对准和得分
   - 触碰梯子完成

### **GOLD机器人 - 红方左侧冲刺程序**

**起始位置**: 机器人位于红方左侧起始位置
**总用时**: 约15秒
**策略**: 抓取对方移动目标，收集多个环堆栈，清理场地角落

#### **第一阶段：抓取对方移动目标 (0-3秒)**

1. **冲刺抓取**
   - 左推杆伸出
   - 全速前进39英寸到达对方移动目标
   - 左推杆收缩抓取移动目标

2. **移动到安全位置**
   - 拖拽移动目标到坐标(-21, -50)
   - 目的：避开对方机器人干扰

#### **第二阶段：移动目标定位 (3-5秒)**

3. **转向释放位置**
   - 转向坐标(-24, -72)
   - 降低电压到9V精确控制

4. **释放移动目标**
   - 左推杆伸出释放移动目标
   - 前进3英寸
   - 等待0.5秒确保稳定
   - 后退7英寸
   - 推杆收缩

#### **第三阶段：抓取己方移动目标 (5-7秒)**

5. **转向己方移动目标**
   - 转向坐标(0, -49)，背对该点
   - 以低电压7V精确移动

6. **抓取己方移动目标**
   - 移动目标机构激活抓取
   - 目的：获得己方移动目标用于得分

#### **第四阶段：收集环堆栈 (7-11秒)**

7. **启动收集系统**
   - 滚轮12V正转
   - 传送带9V正转
   - 目的：开始自动收集环

8. **收集第一个双环堆栈**
   - 转向坐标(-38, -31)
   - 移动到该位置收集环

9. **收集第二个双环堆栈**
   - 以低速4V移动到坐标(-56, -19)
   - 目的：精确收集环堆栈

10. **移动到四环堆栈**
    - 转向坐标(-48, -48)
    - 移动到该位置准备收集大堆栈

#### **第五阶段：角落清理 (11-13秒)**

11. **第一次撞击**
    - 转向角落坐标(-72, -72)
    - 以6V电压冲刺700毫秒
    - 后退5英寸

12. **第二次撞击**
    - 重新对准角落
    - 以10V电压冲刺400毫秒
    - 后退7英寸

13. **第三次撞击**
    - 再次对准角落
    - 以10V电压冲刺300毫秒
    - 后退7英寸

14. **第四次撞击**
    - 最后一次对准
    - 以10V电压冲刺300毫秒
    - 后退13英寸

#### **第六阶段：跨场地清理 (13-15秒)**

15. **跨场地移动**
    - 转向坐标(46, -48)
    - 全速移动到对方场地
    - 目的：清理对方角落

16. **对方角落清理**
    - 转向坐标(72, -72)
    - 重复撞击序列清理环
    - 使用推杆清扫残余环

17. **最终定位**
    - 将移动目标放置在角落
    - 释放移动目标机构
    - 移动到最终位置

### **GOLD机器人 - 蓝方右侧冲刺程序**

**完全镜像红方GOLD程序**，所有坐标和方向都相应镜像调整。

### **AWP+1程序（联盟壁桩快速得分）**

**用时**: 约5秒
**策略**: 简单可靠的联盟壁桩得分

#### **执行步骤**

1. **前进定位**
   - 直线前进10英寸
   - 转向90度面向场地中央

2. **收集环**
   - 滚轮12V正转
   - 前进24英寸收集环

3. **前往壁桩**
   - 转向0度面向联盟壁桩
   - 反向行驶1秒到达壁桩

4. **壁桩得分**
   - 前进1.8英寸精确对准
   - 进料系统12V正转2秒
   - 传送带反转将环送入壁桩
   - 前进2秒完成得分

### **编程技能赛程序**

**策略**: 最大化分数，收集所有环和移动目标

#### **第一阶段：初始收集**

1. **收集起始环**
   - 滚轮正转
   - 前进40英寸收集第一个环

2. **抓取第一个移动目标**
   - 转向-90度
   - 后退25英寸到移动目标
   - 移动目标机构抓取

#### **第二阶段：环收集循环**

3. **系统性收集**
   - 进料系统全速运转
   - 按预定路径收集多个环
   - 前进6英寸，转向0度，前进24英寸
   - 转向90度，前进14英寸

4. **角落清理**
   - 转向-180度
   - 等待1秒让系统稳定
   - 前进50英寸到角落

#### **第三阶段：得分循环**

5. **角落撞击**
   - 转向135度面向角落
   - 冲刺1秒收集角落环
   - 等待1.5秒让环进入系统

6. **环分拣**
   - 传送带反转0.5秒丢弃错误颜色
   - 传送带正转继续收集

7. **移动目标得分**
   - 后退10英寸
   - 转向-45度
   - 反向冲刺1秒到得分位置
   - 传送带反转完成得分
   - 释放移动目标

#### **第四阶段：第二轮收集**

8. **重新定位**
   - 前进15英寸离开角落
   - 等待5秒系统重置

9. **第二个移动目标**
   - 进料系统启动
   - 前进80英寸到第二个移动目标
   - 重复抓取和得分流程

10. **最终清理**
    - 系统性清理剩余环
    - 最大化最终得分

## 🔧 JAR-Template底盘系统

### **JAR-Template名称含义**
- **JAR**: 开发者名字缩写，代表这个库的创作者
- **Template**: 模板，表示这是一个可重用的标准化底盘控制框架
- **目标**: 为VEX机器人竞赛提供高性能、易用的底盘控制解决方案

### **核心特性**
- **精确定位**: 使用编码器和IMU进行位置追踪
- **PID控制**: 独立的驱动、转向、摆动PID控制器
- **路径规划**: 支持点到点导航和路径跟踪
- **自动校准**: 陀螺仪自动校准和误差补偿

### **控制参数**
```cpp
// 驱动PID: kP=12, kI=1.5, kD=0, 启动电压=10, 积分区间=0
chassis.set_drive_constants(12, 1.5, 0.0, 10, 0);

// 转向PID: kP=6, kI=0.5, kD=0, 启动电压=1.2, 积分区间=0  
chassis.set_heading_constants(6, .5, 0, 1.2, 0);

// 旋转PID: kP=12, kI=0.4, kD=0.01, 启动电压=3.1, 积分区间=15
chassis.set_turn_constants(12, .4, 0.01, 3.1, 15);
```

### **运动函数**
- `chassis.drive_distance(distance)`: 直线驱动
- `chassis.turn_to_angle(angle)`: 转向指定角度
- `chassis.drive_to_point(x, y)`: 驱动到指定坐标
- `chassis.turn_to_point(x, y)`: 转向指定坐标

*详细算法解析请参见下方的"JAR-Template底盘系统详细算法解析"部分*

## 🎨 颜色分拣系统详解

### **硬件配置**
- **光学传感器**: PORT19，25%亮度
- **距离传感器**: PORT20，检测环的存在
- **集成时间**: 5ms，快速响应

### **颜色识别算法**
```cpp
// 获取色调值
ringColor = colorDetect.hue();

// 红色判定：350-360度 或 0-10度
bool ringIsRed = ringColor >= 350 || ringColor <= 10;

// 蓝色判定：205-225度  
bool ringIsBlue = ringColor >= 205 && ringColor <= 225;
```

### **分拣逻辑**
1. **距离检测**: 检测环是否接近传感器
2. **颜色识别**: 读取环的色调值
3. **阵营判断**: 根据机器人阵营决定保留或丢弃
4. **执行动作**: 控制传送带正转或反转

### **分拣模式**
- **红方模式**: 保留红色环，丢弃蓝色环
- **蓝方模式**: 保留蓝色环，丢弃红色环
- **覆盖模式**: 手动控制时禁用自动分拣

## 🔩 壁桩控制系统

### **四状态控制**
0. **归零状态 (ZERO_STATE)**
   - 角度：0度（角度传感器读数）
   - 功能：初始化位置，确保系统回到基准点
   - 触发：系统启动、得分完成、手动中断后

1. **装载状态 (LOADING)**
   - 角度：16度
   - 功能：接收环的装载位置
   - 触发：等待传送带电流检测

2. **预得分状态 (PRESCORING)**
   - 角度：75度
   - 功能：准备得分位置
   - 特殊：按Y键可微调到59度并自动回收到归零状态

3. **得分状态 (SCORING)**
   - 角度：60度
   - 功能：最终得分位置
   - 执行：得分后自动平滑回到0度并重置到归零状态

### **PID控制参数**
- **装载**: kP=300/200, kD=0, 容差=1度
- **预得分**: kP=250, kD=0, 容差=3度
- **得分**: kP=200, kD=0, 容差=5度

### **角度传感器处理**
- **归一化处理**: 自动将角度值归一化到0-360度范围
- **环绕问题**: 智能处理358-360度等同于0度的情况
- **最短路径**: 自动选择最短的旋转路径到达目标角度
- **误差处理**: 容差设置为3度，确保在传感器精度范围内稳定

### **手动控制**
- **右摇杆Y轴**: 直接控制壁桩电机
- **覆盖自动**: 手动控制时禁用自动状态机

## 🛠️ 气动系统

### **移动目标机构 (mogoMech)**
- **端口**: Brain.ThreeWirePort.H
- **功能**: 抓取和释放移动目标
- **控制**: R2键切换，带震动反馈

### **推杆系统**
- **左推杆**: Brain.ThreeWirePort.F (B键控制)
- **右推杆**: Brain.ThreeWirePort.G (Down键控制)
- **功能**: 推动环和阻挡对手

### **翻转器 (tipper)**
- **控制**: Right键
- **功能**: 翻转环或触碰梯子

## 📊 传感器系统

### **IMU陀螺仪 (PORT21)**
- **功能**: 提供精确的角度和角速度数据
- **校准**: 自动程序开始时自动校准
- **用途**: 底盘控制和自动程序导航

### **距离传感器 (PORT20)**
- **功能**: 检测环的距离
- **阈值**: 2.5英寸内检测到环
- **用途**: 自动进料和颜色分拣触发

### **旋转传感器 (PORT15)**
- **功能**: 监测壁桩角度
- **精度**: 1度分辨率
- **用途**: 壁桩位置反馈和PID控制

## 项目结构

```
VEXCODE-2024-2025/
├── src/                    # 源代码目录
│   ├── main.cpp           # 主程序文件
│   ├── robot-config.cpp   # 机器人配置
│   └── autons.cpp         # 自动程序
├── include/               # 头文件目录
│   ├── robot-config.h     # 机器人配置头文件
│   └── autons.h          # 自动程序头文件
├── JAR-Template/          # 底盘驱动系统库
└── vex/                   # VEX编译配置
```

## 功能特性

- **高级底盘控制**: 使用JAR-Template库实现精确的位置追踪和PID控制
- **智能颜色分拣**: 自动识别环颜色并根据阵营进行分拣
- **多状态壁桩系统**: 支持装载、预得分、得分多种状态
- **完整的自动程序**: 支持红蓝双方多种策略
- **气动系统控制**: 移动目标机构和推杆系统
- **传感器集成**: IMU、光学传感器、距离传感器等

## 🚀 使用指南

### **编译和部署**
1. 使用VEXcode Pro V5打开项目
2. 确认makefile中的机器人配置（GREEN/GOLD）
3. 编译并下载到机器人大脑

### **自动程序使用**
1. 开机后进入自动程序选择界面
2. 点击Brain屏幕循环选择程序
3. 按X键锁定选择的自动程序并校准陀螺仪
4. 确认机器人位置正确后开始比赛

### **手动控制**
1. 使用左摇杆控制底盘移动
2. 使用肩部按键控制进料系统
3. 使用R1键切换壁桩状态
4. 使用方向键设置颜色分拣模式

### **调试和测试**
1. 使用Brain屏幕查看传感器数据
2. 使用Controller屏幕查看状态信息
3. 使用printf输出调试信息到终端

## 🔧 JAR-Template底盘系统详细算法解析

### **系统架构概述**
JAR-Template是一个先进的机器人底盘控制系统，集成了多种算法来实现精确的位置控制和路径规划。

### **核心算法组件**

#### **1. PID控制器算法**

PID控制器是整个系统的核心，使用经典的比例-积分-微分控制算法：

```cpp
output = kP*error + kI*accumulated_error + kD*(error-previous_error)
```

**算法特点：**
- **比例项(P)**: 根据当前误差提供即时响应
- **积分项(I)**: 消除稳态误差，只在误差小于`starti`时开始积分
- **微分项(D)**: 预测误差变化趋势，提供阻尼效果
- **零点穿越重置**: 当误差从正变负或从负变正时，自动清零积分项
- **智能积分**: 防止积分饱和，提高系统稳定性

**稳定判定算法：**
```cpp
// 机器人被认为已稳定当：
// 1. 误差小于settle_error持续时间超过settle_time
// 2. 或者总运行时间超过timeout
if (time_spent_settled > settle_time || time_spent_running > timeout) {
    return true; // 已稳定
}
```

#### **2. 里程计算法(Odometry)**

使用**Pilons弧长法**进行位置追踪，这是VEX机器人中最精确的定位算法：

**数学原理：**
1. **局部坐标系计算**：
```cpp
if (orientation_delta_rad == 0) {
    // 直线运动
    local_X = Sideways_delta;
    local_Y = Forward_delta;
} else {
    // 弧形运动
    local_X = (2*sin(δθ/2)) * ((Sideways_delta/δθ) + SidewaysTracker_center_distance);
    local_Y = (2*sin(δθ/2)) * ((Forward_delta/δθ) + ForwardTracker_center_distance);
}
```

2. **全局坐标系转换**：
```cpp
// 将局部位移转换为全局坐标
global_angle = local_polar_angle - prev_orientation - (orientation_delta/2);
X_delta = local_polar_length * cos(global_angle);
Y_delta = local_polar_length * sin(global_angle);
```

**追踪轮配置：**
- **前向追踪轮**: 测量前后移动距离
- **侧向追踪轮**: 测量左右移动距离  
- **IMU陀螺仪**: 提供精确的角度测量
- **中心距离补偿**: 考虑追踪轮到机器人中心的距离

#### **3. 点到点导航算法**

**基础drive_to_point算法：**
```cpp
while (!drivePID.is_settled()) {
    // 计算到目标点的距离和角度
    distance_error = hypot(target_X - current_X, target_Y - current_Y);
    heading_error = atan2(target_X - current_X, target_Y - current_Y) - current_heading;
    
    // 双PID控制
    drive_output = drivePID.compute(distance_error);
    heading_output = headingPID.compute(heading_error);
    
    // 角度缩放因子：当朝向偏差大时减少前进速度
    heading_scale_factor = cos(heading_error);
    drive_output *= heading_scale_factor;
    
    // 输出到电机
    left_voltage = drive_output + heading_output;
    right_voltage = drive_output - heading_output;
}
```

#### **4. Boomerang控制器算法**

这是JAR-Template最先进的路径规划算法，用于`drive_to_pose`函数：

**算法原理：**
1. **胡萝卜点(Carrot Point)计算**：
```cpp
// 胡萝卜点始终在目标点前方
carrot_X = target_X - sin(target_angle) * (lead * distance_to_target + setback);
carrot_Y = target_Y - cos(target_angle) * (lead * distance_to_target + setback);
```

2. **动态目标追踪**：
   - 机器人始终朝向动态移动的胡萝卜点
   - 胡萝卜点随着机器人接近目标而移动
   - 当接近目标时切换到最终角度控制

3. **智能后退逻辑**：
   - 如果后退到达目标更快，算法自动选择后退
   - 避免不必要的转向，提高效率

**参数说明：**
- **lead**: 胡萝卜点的前置距离系数（通常0.5）
- **setback**: 胡萝卜点的固定后退距离
- **crossed_center_line**: 检测是否穿过目标线，防止震荡

#### **5. 转向算法**

**turn_to_angle算法：**
```cpp
while (!turnPID.is_settled()) {
    error = reduce_negative_180_to_180(target_angle - current_angle);
    output = turnPID.compute(error);
    
    // 差速转向：左右轮反向旋转
    left_voltage = output;
    right_voltage = -output;
}
```

**turn_to_point算法：**
```cpp
// 计算到目标点的角度
target_angle = atan2(target_X - current_X, target_Y - current_Y) + extra_angle;
// 然后使用turn_to_angle算法
```

#### **6. 全向驱动算法**

对于麦克纳姆轮等全向驱动系统：

```cpp
// 同时控制位置和角度
while (!(drivePID.is_settled() && turnPID.is_settled())) {
    drive_output = drivePID.compute(distance_error);
    turn_output = turnPID.compute(angle_error);
    
    // 麦克纳姆轮运动学计算
    heading_error = atan2(Y_error, X_error);
    
    // 四个轮子的速度分配
    LF_speed = drive_output * cos(current_heading + heading_error - π/4) + turn_output;
    LB_speed = drive_output * cos(-current_heading - heading_error + 3π/4) + turn_output;
    RB_speed = drive_output * cos(current_heading + heading_error - π/4) - turn_output;
    RF_speed = drive_output * cos(-current_heading - heading_error + 3π/4) - turn_output;
}
```

### **控制参数优化**

#### **当前系统参数：**
```cpp
// 驱动PID参数
drive_kP = 12;    // 比例增益：控制响应速度
drive_kI = 1.5;   // 积分增益：消除稳态误差
drive_kD = 0;     // 微分增益：提供阻尼
drive_starti = 0; // 积分启动阈值
drive_min_voltage = 10; // 最小启动电压

// 转向PID参数
heading_kP = 6;   // 角度控制比例增益
heading_kI = 0.5; // 角度控制积分增益
heading_kD = 0;   // 角度控制微分增益
heading_min_voltage = 1.2; // 转向最小电压

// 旋转PID参数
turn_kP = 12;     // 原地转向比例增益
turn_kI = 0.4;    // 原地转向积分增益
turn_kD = 0.01;   // 原地转向微分增益
turn_starti = 15; // 积分启动阈值
turn_min_voltage = 3.1; // 转向最小电压
```

#### **参数调优指南：**
1. **kP值过大**: 系统震荡，超调严重
2. **kP值过小**: 响应慢，可能无法到达目标
3. **kI值过大**: 系统不稳定，可能震荡
4. **kI值过小**: 存在稳态误差
5. **kD值过大**: 系统对噪声敏感
6. **kD值过小**: 缺乏阻尼，可能超调

### **算法优化特性**

#### **1. 智能电压缩放**
```cpp
// 根据角度误差缩放驱动电压
heading_scale_factor = cos(heading_error);
drive_output *= heading_scale_factor;

// 当角度误差大时，减少前进速度，优先纠正方向
```

#### **2. 最小电压阈值**
```cpp
// 确保电机有足够力矩克服静摩擦
if (abs(output) < min_voltage && abs(output) > 0) {
    output = (output > 0) ? min_voltage : -min_voltage;
}
```

#### **3. 角度归一化**
```cpp
// 将角度限制在[-180°, 180°]范围内
float reduce_negative_180_to_180(float angle) {
    while (angle > 180) angle -= 360;
    while (angle < -180) angle += 360;
    return angle;
}
```

#### **4. 自适应积分区间**
```cpp
// 只在误差较小时开始积分，防止积分饱和
if (fabs(error) < starti) {
    accumulated_error += error;
}
```

### **实时性能优化**

#### **1. 200Hz控制循环**
- 里程计更新频率：200Hz（每5ms）
- PID计算频率：100Hz（每10ms）
- 确保控制系统的实时响应

#### **2. 多线程架构**
```cpp
// 里程计在独立线程中运行
vex::task odom_task = vex::task(position_track_task);

// 主控制循环与位置追踪并行执行
while (!PID.is_settled()) {
    // PID计算和电机控制
    task::sleep(10); // 10ms控制周期
}
```

#### **3. 内存优化**
- 使用浮点数进行精确计算
- 避免重复的三角函数计算
- 优化的数据结构减少内存占用

### **运动函数API**

#### **基础运动函数**
- `drive_distance(distance)`: 直线驱动指定距离
- `turn_to_angle(angle)`: 转向指定角度
- `drive_to_point(x, y)`: 驱动到指定坐标点
- `turn_to_point(x, y)`: 转向指定坐标点

#### **高级运动函数**
- `drive_to_pose(x, y, angle)`: 使用Boomerang算法到达指定姿态
- `holonomic_drive_to_pose(x, y, angle)`: 全向驱动到指定姿态
- `left_swing_to_angle(angle)`: 左轮固定的摆动转向
- `right_swing_to_angle(angle)`: 右轮固定的摆动转向

### **错误处理和安全机制**

#### **1. 超时保护**
```cpp
if (time_spent_running > timeout && timeout != 0) {
    return true; // 强制退出，防止死循环
}
```

#### **2. 电压限制**
```cpp
// 防止电机过载
output = clamp(output, -max_voltage, max_voltage);
```

#### **3. 稳定性检测**
```cpp
// 多重条件确保运动完成
bool is_settled = (error < settle_error) && (time_settled > settle_time);
```

这个算法系统的设计哲学是**精确性、稳定性和效率**的完美结合，使机器人能够在复杂的比赛环境中实现毫米级的定位精度和流畅的运动控制。
